/**
 * NOTICE:
 * This file is generated and managed programmatically by Innate.
 * Do not edit this file directly. Edits to this file will be overwritten.
 */

import { randomBytes } from 'crypto'
import { GraphQLError } from 'graphql'
import { type Context, InputValidator } from '@shared' // won't resolve until copied to destination
import { Mutation, Resolver, Arg, Field, InputType, Ctx } from 'type-graphql'
import { SendUserVerificationEmailResolver } from './SendUserVerificationEmailResolver'

// @ts-ignore
import { User } from '../../generated/type-graphql'

@InputType()
abstract class UserRegistrationInput {
  @Field((_type) => String, { nullable: false })
  username: string

  @Field((_type) => String, { nullable: false })
  email: string

  @Field((_type) => String, { nullable: false })
  password: string
}

@Resolver()
export abstract class UserRegistrationResolver {
  @Mutation(() => Boolean, { nullable: true })
  public async registerUser(
    @Arg('UserRegistrationInput', {
      validate: true,
      nullable: false,
      description: 'Register a new user',
    })
    { username, email, password }: UserRegistrationInput,

    @Ctx() context: Context,
  ): Promise<boolean> {
    const { request } = context

    InputValidator.validateEmail(email, request)
    InputValidator.validatePassword(password, request)
    InputValidator.validateDisplayName(username, request)

    const salt = randomBytes(16).toString('base64')
    const hash = await Bun.password.hash(`${salt}${password}`)

    await this.createUser({ hash, salt, email, username }, context)

    return true
  }

  private async createUser(
    {
      hash,
      salt,
      email,
      username,
    }: {
      hash: string
      salt: string
      email: string
      username: string
    },
    context: Context,
  ): Promise<User | null> {
    try {
      const emailExists = await context.prisma.user.findUnique({
        where: {
          email,
        },
      })

      if (emailExists) throw new Error('Email exists')

      const newUser = await context.prisma.user.create({
        data: {
          email,
          username,
          hash,
          salt,
          verified: false,

          banned: false,
        },
      })

      await SendUserVerificationEmailResolver.sendUserConfirmationEmail(
        newUser.email,
        context,
      )

      return newUser
    } catch (error: any) {
      if (error.message === 'Username exists') {
        throw new Error(
          'A user with that username already exists. Please try another.',
        )
      }

      if (
        error.code === 'P2002' && // Prisma unique contraint error code
        error.meta.target.includes('email')
      ) {
        const accountOwner = await context.prisma.user.findUnique({
          where: {
            email,
          },
        })

        /* c8 ignore start */

        /**
         * This isn't likely to ever happen because this db search
         * is triggered when the user exists already
         */
        if (!accountOwner) {
          throw new GraphQLError('An unknown error occurred')
        }

        /* c8 ignore stop */
      }

      return null
    }
  }
}
